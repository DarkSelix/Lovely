<!doctype html>
<html lang=en>
<head>
<meta charset=UTF-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<title>LolvableAI - Advanced Chat</title>
<script src=https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.2/marked.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.38.0/min/vs/loader.min.js></script>
<style>
:root {
    --primary-color: #8b5cf6; /* Purple */
    --primary-hover: #7c3aed;
    --secondary-color: #c4b5fd; /* Light Purple */
    --background-dark: #0f172a; /* Deep Blue/Black */
    --background-medium: #1e293b; /* Dark Slate */
    --background-light: #334155; /* Medium Slate */
    --text-primary: #e2e8f0; /* Light Gray/White */
    --text-secondary: #94a3b8; /* Medium Gray */
    --text-accent: var(--primary-color);
    --border-color: #334155;
    --danger-color: #f87171; /* Red */
    --success-color: #10b981; /* Green */
    --font-sans: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,sans-serif;
    --border-radius: .5rem;
    --shadow-md: 0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -2px rgba(0,0,0,.1);
    --shadow-lg: 0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -4px rgba(0,0,0,.1);
}

*{margin:0;padding:0;box-sizing:border-box;font-family:var(--font-sans)}
body{min-height:100vh;background-color:var(--background-dark);color:var(--text-primary);display:flex;justify-content:center;align-items:center;padding:1rem}
.container{max-width:80rem;width:100%;height:calc(100vh - 2rem);display:flex;gap:1rem}

.glass-effect {
    background:rgba(30, 41, 59, 0.6);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(51, 65, 85, 0.3);
}

.chat-container{
    border-radius:var(--border-radius);
    overflow:hidden;
    box-shadow:var(--shadow-lg);
    flex:1;display:flex;flex-direction:column;
    height:100%;
}
.chat-container.glass-effect { background:rgba(30, 41, 59, 0.75); }


.chat-header{
    background-color:rgba(15, 23, 42, 0.7);
    padding:1rem 1.5rem;display:flex;align-items:center;justify-content:space-between;
    border-bottom:1px solid var(--border-color);
    position:relative;
}
.header-content{display:flex;align-items:center; overflow: hidden;}
.header-icon{width:2.5rem;height:2.5rem;border-radius:50%;background-color:var(--primary-color);display:flex;align-items:center;justify-content:center;margin-right:1rem; box-shadow: var(--shadow-md); flex-shrink: 0;}
.header-icon svg { stroke: white; }
.header-title{font-size:1.5rem;font-weight:600;color:var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
.header-actions { display: flex; gap: 0.5rem; flex-shrink: 0;}
.header-button{background:0 0;border:none;color:var(--text-secondary);cursor:pointer;padding:.5rem;border-radius:.25rem; transition: background-color .2s, color .2s;}
.header-button:hover{background-color:var(--background-light); color: var(--text-primary);}
.header-button svg { width: 20px; height: 20px; }

.sidebar{
    width:0;
    border-radius:var(--border-radius);
    margin-right:0;transition:all .3s ease;overflow:hidden;
    display:flex;flex-direction:column;
    height:100%;
}
.sidebar.glass-effect { background:rgba(15, 23, 42, 0.75); }
.sidebar.open{width:20rem;margin-right:1rem;padding:0.5rem; box-shadow: var(--shadow-lg);}
.sidebar-header{padding:1rem;border-bottom:1px solid var(--border-color);display:flex;justify-content:space-between;align-items:center}
.sidebar-title{font-size:1.25rem;font-weight:600;color:var(--secondary-color)}
.sidebar-close{background:0 0;border:none;color:var(--text-primary);cursor:pointer;padding:0.25rem;}
.sidebar-close:hover{color:var(--primary-color);}
.sidebar-tabs{display:flex;border-bottom:1px solid var(--border-color);margin:0 -0.5rem;}
.sidebar-tab{flex:1;padding:1rem;text-align:center;cursor:pointer;border:none;background:0 0;color:var(--text-secondary);font-weight:500; transition: color .2s, border-color .2s;}
.sidebar-tab.active{color:var(--primary-color);border-bottom:2px solid var(--primary-color)}
.sidebar-tab:not(.active):hover { color: var(--text-primary); }
.sidebar-content{flex:1;overflow-y:auto;padding:1rem;}
.new-chat-button {
    display: flex; align-items: center; justify-content: center;
    width: 100%; text-align: center;
    padding: .75rem 1rem; margin-bottom: .75rem;
    background-color: var(--primary-color); color: white;
    border: none; border-radius: var(--border-radius);
    cursor: pointer; font-weight: 500; transition: background-color .2s;
}
.new-chat-button:hover { background-color: var(--primary-hover); }
.new-chat-button svg { margin-right: 0.5em; }

.history-list{list-style:none}
.history-item{
    display: flex; justify-content: space-between; align-items: center;
    padding:.75rem 1rem;border-radius:.25rem;cursor:pointer;margin-bottom:.5rem;
    transition: background-color .2s; color: var(--text-secondary);
}
.history-item:hover{background-color:var(--background-medium); color: var(--text-primary);}
.history-item.active-chat { background-color: var(--background-light); color: var(--text-primary); font-weight: 500; }

.history-item-title {
    flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    margin-right: 0.5rem; /* Space before action buttons */
}
.history-item-actions {
    display: flex; gap: 0.35rem; flex-shrink: 0;
    opacity: 0; visibility: hidden; /* Hidden by default */
    transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
}
.history-item:hover .history-item-actions {
    opacity: 1; visibility: visible; /* Show on hover */
}
.history-item.active-chat .history-item-actions { /* Keep actions visible for active chat if desired */
    opacity: 1; visibility: visible;
}
.history-action-btn {
    background: none; border: none; color: var(--text-secondary);
    cursor: pointer; padding: 0.2rem; border-radius: 0.25rem;
    display: flex; align-items: center; justify-content: center;
}
.history-action-btn:hover {
    color: var(--text-primary); background-color: var(--background-dark);
}
.history-action-btn svg { width: 14px; height: 14px; }


.settings-section{margin-bottom:1.5rem}
.settings-label{display:block;margin-bottom:.5rem;font-weight:500;color:var(--secondary-color)}
.settings-input,.settings-select,.settings-textarea{
    width:100%;padding:.75rem;background-color:var(--background-medium);color:var(--text-primary);
    border:1px solid var(--border-color);border-radius:.25rem;
    transition: border-color .2s, box-shadow .2s;
}
.settings-input:focus,.settings-select:focus,.settings-textarea:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px var(--primary-hover);
    outline: none;
}
.settings-textarea{min-height:8rem;resize:vertical}
.settings-button{
    background-color:var(--primary-color);color:#fff;border:none;border-radius:.25rem;
    padding:.75rem 1.5rem;cursor:pointer;margin-top:.5rem;font-weight:500;
    transition: background-color .2s;
}
.settings-button:hover{background-color:var(--primary-hover)}

.chat-body{flex:1;overflow-y:auto;padding:1.5rem;background-color:transparent;}
.message{display:flex;gap:1rem;margin-bottom:1.5rem;align-items:flex-start; animation: fadeIn 0.3s ease-out;}
.message.user-message{flex-direction:row-reverse}
.avatar{width:2.5rem;height:2.5rem;border-radius:50%;display:flex;align-items:center;justify-content:center;flex-shrink:0; box-shadow: var(--shadow-md);}
.user-avatar{background-color:var(--primary-hover); color: white;}
.bot-avatar{background-color:var(--background-light); color: var(--text-primary);}
.avatar svg { width: 1.25rem; height: 1.25rem; }

.message-content{position:relative;max-width:calc(100% - 4.5rem); }
.message-bubble{
    padding:1rem 1.25rem;border-radius:var(--border-radius);word-break:break-word;
    box-shadow:var(--shadow-md); line-height: 1.6;
}
.user-bubble{background-color:var(--primary-color);color:white;}
.bot-bubble{background-color:var(--background-medium); color: var(--text-primary);}

.message-bubble p:last-child { margin-bottom: 0; }
.message-bubble strong { color: var(--secondary-color); }
.message-bubble em { font-style: italic; }
.message-bubble ul, .message-bubble ol { margin-left: 1.5rem; padding-left: 0.5rem; }
.message-bubble li { margin-bottom: 0.25rem; }
.message-bubble blockquote {
    border-left: 3px solid var(--primary-color);
    padding-left: 1rem; margin-left: 0; margin-top: 0.5rem; margin-bottom: 0.5rem;
    color: var(--text-secondary); font-style: italic;
}
.message-bubble code:not(pre code) {
    background-color: var(--background-dark); color: var(--secondary-color);
    padding: .2em .4em; margin: 0; font-size: 85%; border-radius: 3px;
}

.text-white{color:var(--text-primary)}
.text-red{color:var(--danger-color)}
.text-purple{color:var(--primary-color)}
.text-black{color:#000;background-color:#fecaca;padding:0.1em 0.3em;border-radius:3px;}

.message-info{display:flex;justify-content:space-between;align-items:center;margin-top:.5rem;}
.message-time{color:var(--text-secondary);font-size:.75rem;}

.message-actions-trigger {
    position: absolute; top: .5rem;
    background: transparent; border: none; color: var(--text-secondary);
    cursor: pointer; padding: .25rem; border-radius: 50%;
    opacity: 0; transition: opacity .2s, background-color .2s;
    display: flex; align-items: center; justify-content: center;
}
.message-content:hover .message-actions-trigger { opacity: 1; }
.message-actions-trigger:hover { background-color: rgba(255,255,255,0.1); }
.user-message .message-actions-trigger { left: -2.25rem; }
.bot-message .message-actions-trigger { right: -2.25rem; }


.message-actions-menu {
    position: absolute;
    top: 2rem; 
    background-color: var(--background-light);
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-lg);
    padding: .5rem 0;
    z-index: 20;
    display: none;
    min-width: 150px;
}
.user-message .message-actions-menu { left: 0; }
.bot-message .message-actions-menu { right: 0; }
.message-actions-menu.active { display: block; }

.action-button{
    display: flex; align-items: center; gap: 0.5rem;
    padding: .5rem 1rem; background:0 0;border:none;color:var(--text-primary);
    cursor:pointer; width: 100%; text-align: left; font-size: 0.875rem;
    transition: background-color .2s;
}
.action-button svg { width: 14px; height: 14px; stroke-width: 2; }
.action-button:hover{background-color:var(--primary-color); color: white;}
.action-button.delete:hover { background-color: var(--danger-color); }


.code-block{position:relative;margin:1rem 0;background-color:var(--background-medium);border-radius:var(--border-radius);overflow:hidden; box-shadow: var(--shadow-md);}
.code-header{
    display:flex;justify-content:space-between;align-items:center;
    background-color:var(--background-light);padding:.5rem 1rem;
    font-family:monospace; font-size: 0.875rem;
}
.code-language{color:var(--text-secondary); text-transform: uppercase;}
.code-actions{display:flex;gap:.5rem}
.code-copy{background:0 0;border:none;color:var(--text-primary);cursor:pointer;padding:.25rem .5rem;border-radius:.25rem; display: flex; align-items: center; gap: 0.25rem; font-size: 0.8rem;}
.code-copy:hover{background-color:var(--primary-color); color: white;}
.code-copy svg { width: 14px; height: 14px; }
.code-copy-success{color:var(--success-color)!important;}
.code-editor{border-bottom-left-radius:var(--border-radius);border-bottom-right-radius:var(--border-radius);overflow:hidden;height:300px;}
.monaco-editor .monaco-editor-background, .monaco-editor .margin { background-color: #1e1e1e !important; }


.input-area{
    padding:1rem 1.5rem;background-color:rgba(30, 41, 59, 0.7);
    border-top:1px solid var(--border-color);display:flex;gap:1rem;align-items:flex-end;
}
.input-field{
    flex:1;background-color:var(--background-dark);color:var(--text-primary);
    border-radius:var(--border-radius);padding:1rem;resize:none;
    border:1px solid var(--border-color);outline:0;min-height:50px;max-height:200px;
    font-size: 1rem; line-height: 1.5;
    transition: border-color .2s, box-shadow .2s;
}
.input-field:focus{border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(139,92,246,0.3); }
.send-button{
    background-color:var(--primary-color);color:#fff;border:none;
    border-radius:var(--border-radius);padding:0;cursor:pointer;
    transition:background-color .2s, opacity .2s;
    width: 50px; height: 50px; display: flex; align-items: center; justify-content: center;
    flex-shrink: 0;
}
.send-button svg { width: 1.25rem; height: 1.25rem; }
.send-button:hover:not(:disabled){background-color:var(--primary-hover)}
.send-button:disabled{opacity:.5;cursor:not-allowed}

.typing-indicator {
    display:flex; gap: 0.75rem; align-items:flex-start;
    padding: 1rem 1.5rem; margin-left: calc(2.5rem + 1rem);
}
.typing-text {
    font-style: italic; color: var(--text-secondary);
    background-color: var(--background-medium);
    padding: 0.75rem 1.25rem;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-md);
}
.typing-dot{
    display: inline-block; width: 6px; height: 6px;
    background-color: var(--text-secondary); border-radius: 50%;
    animation: typingBounce 1.4s infinite ease-in-out both;
}
.typing-dot:nth-child(1) { animation-delay: -0.32s; }
.typing-dot:nth-child(2) { animation-delay: -0.16s; }
@keyframes typingBounce {
  0%, 80%, 100% { transform: scale(0); }
  40% { transform: scale(1.0); }
}

@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
.delete-animation{animation:fadeOut .3s ease-out forwards}@keyframes fadeOut{from{opacity:1;transform:translateY(0);max-height:500px}to{opacity:0;transform:translateY(-10px);max-height:0;margin:0;padding:0}}

.thinking{font-style:italic;opacity:.85}
.scream{font-weight:700;text-transform:uppercase; color: var(--danger-color);letter-spacing: .05em;}

.edit-area{
    width:100%;padding:.75rem;background-color:var(--background-dark);color:var(--text-primary);
    border:1px solid var(--border-color);border-radius:.25rem;margin-top:.5rem;
    resize:vertical;min-height:100px; font-size: 0.95rem; line-height: 1.5;
}
.edit-controls{display:flex;justify-content:flex-end;gap:.5rem;margin-top:.5rem}
.edit-button, .cancel-button{
    color:#fff;border:none;border-radius:.25rem;
    padding:.5rem 1rem;cursor:pointer; font-weight: 500;
    transition: background-color .2s;
}
.edit-button{background-color:var(--primary-color);}
.edit-button:hover{background-color:var(--primary-hover)}
.cancel-button{background-color:var(--background-light);}
.cancel-button:hover{background-color:var(--border-color);}

.modal {
    display: none; position: fixed; z-index: 100;
    left: 0; top: 0; width: 100%; height: 100%;
    overflow: auto; background-color: rgba(0,0,0,0.6);
    align-items: center; justify-content: center;
}
.modal.active { display: flex; }
.modal-content {
    background-color: var(--background-medium);
    margin: auto; padding: 2rem;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    width: 90%; max-width: 600px;
    box-shadow: var(--shadow-lg);
    position: relative;
}
.modal-close {
    color: var(--text-secondary);
    position: absolute; top: 1rem; right: 1.5rem;
    font-size: 1.5rem; font-weight: bold; cursor: pointer;
}
.modal-close:hover, .modal-close:focus { color: var(--text-primary); }
.modal-title { margin-top:0; margin-bottom:1.5rem; color: var(--secondary-color); font-size:1.5rem;}
.context-entry {
    margin-bottom: 1rem; padding: 0.75rem;
    border-radius: .25rem; background-color: var(--background-dark);
    border: 1px solid var(--border-color);
}
.context-role { font-weight: bold; color: var(--primary-color); text-transform: capitalize; margin-bottom: 0.25rem;}
.context-text { white-space: pre-wrap; word-break: break-word; font-size: 0.9rem; line-height: 1.5; }

/* --- Mobile Responsiveness --- */
@media (max-width: 768px) {
    body { padding: 0; align-items: flex-start; }
    .container { flex-direction: column; height: 100vh; max-width: 100%; gap: 0; border-radius: 0; }
    .sidebar {
        position: fixed; left: -100%; top: 0; height: 100%; z-index: 200;
        width: 85vw; max-width: 300px; margin-right: 0; border-radius: 0;
        box-shadow: var(--shadow-lg); transition: left 0.3s ease-in-out;
    }
    .sidebar.open { left: 0; }
    .sidebar.glass-effect { background:rgba(15, 23, 42, 0.85); }
    .chat-container { width: 100%; height: 100vh; border-radius: 0; }
    .chat-container.glass-effect { background:rgba(30, 41, 59, 0.85); }
    .chat-header { padding: 0.75rem 1rem; }
    .header-title { font-size: 1.25rem; }
    .header-icon { width: 2rem; height: 2rem; margin-right: 0.75rem; }
    .header-icon svg { width: 1rem; height: 1rem; }
    .chat-body { padding: 1rem; }
    .message { gap: 0.75rem; margin-bottom: 1rem; }
    .avatar { width: 2.25rem; height: 2.25rem; }
    .message-content { max-width: calc(100% - 3.5rem); }
    .message-bubble { padding: 0.75rem 1rem; }
    .user-message .message-actions-trigger { left: auto; right: 0.25rem; top: 0.25rem; }
    .bot-message .message-actions-trigger { right: 0.25rem; top: 0.25rem; }
    .message-actions-trigger { padding: 0.4rem; }
    .message-actions-menu { top: 2.25rem; left: auto; right: 0.25rem; min-width: 160px; }
    .input-area { padding: 0.75rem 1rem; gap: 0.75rem; }
    .input-field { padding: 0.75rem; min-height: 44px; font-size: 0.95rem; }
    .send-button { width: 44px; height: 44px; }
    .send-button svg { width: 1.1rem; height: 1.1rem; }
    .modal-content { width: 90vw; padding: 1.5rem; max-height: 80vh; overflow-y: auto; }
    .modal-title { font-size: 1.25rem; }
    .history-item-actions { opacity: 0.6; visibility: visible; /* Make them more visible on mobile if always shown */ }
}
@media (max-width: 480px) {
    .header-title { font-size: 1.1rem; }
    .header-actions .header-button svg { width: 18px; height: 18px; }
    .message-bubble { font-size: 0.9rem; }
    .message-time { font-size: .7rem; }
    .input-field { font-size: 0.9rem; }
    .sidebar.open {width: 95vw; max-width: none;}
}
</style>
</head>
<body>
<div class="container">
    <div id="sidebar" class="sidebar glass-effect">
        <div class="sidebar-header">
            <h2 class="sidebar-title">Menu</h2>
            <button id="sidebar-close" class="sidebar-close" aria-label="Close menu">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="sidebar-tabs">
            <button class="sidebar-tab active" data-tab="history">History</button>
            <button class="sidebar-tab" data-tab="settings">Settings</button>
        </div>
        <div class="sidebar-content" id="history-tab">
            <button id="new-chat-button" class="new-chat-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5l0 14"></path><path d="M5 12l14 0"></path></svg>
                New Chat
            </button>
            <ul class="history-list" id="history-list"></ul>
        </div>
        <div class="sidebar-content" id="settings-tab" style="display:none">
            <div class="settings-section">
                <label for="api-key-input" class="settings-label">Chutes.AI API Key</label>
                <input type="password" id="api-key-input" class="settings-input" placeholder="Enter your Chutes.AI API Key">
                <small style="color:var(--text-secondary); font-size: 0.75rem; margin-top: 0.25rem; display: block;">Your API key is stored locally in your browser.</small>
            </div>
            <div class="settings-section">
                <label for="model-select" class="settings-label">AI Model</label>
                <select id="model-select" class="settings-select">
                    <option value="deepseek-ai/DeepSeek-V3-0324" selected>DeepSeek V3 0324</option>
                </select>
            </div>
            <div class="settings-section">
                <label for="ai-persona-input" class="settings-label">AI Persona (Bot's Full System Prompt)</label>
                <textarea id="ai-persona-input" class="settings-textarea" placeholder="Enter the complete system prompt for the AI. If blank, the application's default persona (Velly) will be used. This will define the AI's personality, rules, and instructions."></textarea>
                <small style="color:var(--text-secondary); font-size: 0.75rem; margin-top: 0.25rem; display: block;">This replaces the default system message entirely if filled.</small>
            </div>
            <div class="settings-section">
                <label for="user-persona-input" class="settings-label">Your Persona (How AI sees you)</label>
                <textarea id="user-persona-input" class="settings-textarea" placeholder="Describe yourself, your character, your role, or any relevant context about you that the AI should know. E.g., 'I am a curious space explorer named Captain Alex.'"></textarea>
                <small style="color:var(--text-secondary); font-size: 0.75rem; margin-top: 0.25rem; display: block;">This text will be prepended to your messages to inform the AI.</small>
            </div>
            <button id="save-settings" class="settings-button">Save Settings</button>
        </div>
            <div class="settings-section">
  <h3 style="color: var(--secondary-color); margin-bottom: 0.5rem;">Legal Disclaimer</h3>
  <p style="font-size: 0.85rem; color: var(--text-secondary); line-height: 1.4;">
    This chatbot runs entirely in your browser. No data is stored or sent to any server owned by this site.<br>
    The site owner is not responsible for the content generated or how the chatbot is used.<br>
    Use at your own risk.
  </p>      
       </div>
    </div>

    <div class="chat-container glass-effect">
        <div class="chat-header">
            <div class="header-content">
                <button id="menu-button" class="header-button" aria-label="Open menu">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
                <div class="header-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-bot">
                        <path d="M12 8V4H8"></path><rect width="16" height="12" x="4" y="8" rx="2"></rect><path d="M2 14h2"></path><path d="M20 14h2"></path><path d="M15 13v2"></path><path d="M9 13v2"></path>
                    </svg>
                </div>
                <h1 id="chat-header-title" class="header-title">LolvableAI</h1>
            </div>
            <div class="header-actions">
                <button id="view-context-button" class="header-button" aria-label="View Context/Memory" title="View Context/Memory">
                     <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-brain-cog">
                        <path d="M12 2a4.5 4.5 0 0 0-4.5 4.5v.43a1.5 1.5 0 0 1-1.17 1.41A6.5 6.5 0 0 0 9.5 16v2.5a2.5 2.5 0 0 0 5 0V16a6.5 6.5 0 0 0 3.17-2.66 1.5 1.5 0 0 1-1.17-1.41V6.5A4.5 4.5 0 0 0 12 2Z"/><path d="M20.55 16.5A2.5 2.5 0 0 0 22 14a2.5 2.5 0 0 0-4 2.2c0 .45.12.88.32 1.25"/><path d="M18.5 9.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z"/><path d="M3.45 16.5A2.5 2.5 0 0 1 2 14a2.5 2.5 0 0 1 4 2.2c0 .45-.12.88-.32 1.25"/><path d="M5.5 9.5a2.5 2.5 0 1 1 0-5 2.5 2.5 0 0 1 0 5Z"/>
                    </svg>
                </button>
            </div>
        </div>
        <div id="chat-body" class="chat-body"></div>
        <div id="typing-indicator-area"></div>
        <div class="input-area">
            <textarea id="message-input" class="input-field" placeholder="Type your message... (use -B, -P, -R for colors)" rows="1"></textarea>
            <button id="send-button" class="send-button" aria-label="Send message" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide-send-horizontal">
                    <path d="m3 3 3 9-3 9 19-9Z"/><path d="M6 12h16"/>
                </svg>
            </button>
        </div>
    </div>
</div>

<div id="context-modal" class="modal">
    <div class="modal-content">
        <span id="modal-close-button" class="modal-close">&times;</span>
        <h2 class="modal-title">Current API Context</h2>
        <div id="context-modal-body"></div>
    </div>
</div>

<script>
// --- Global DOM Element References ---
const chatBody = document.getElementById("chat-body");
const messageInput = document.getElementById("message-input");
const sendButton = document.getElementById("send-button");
const menuButton = document.getElementById("menu-button");
const sidebar = document.getElementById("sidebar");
const sidebarClose = document.getElementById("sidebar-close");
const sidebarTabs = document.querySelectorAll(".sidebar-tab");
const historyTab = document.getElementById("history-tab");
const settingsTab = document.getElementById("settings-tab");
const apiKeyInput = document.getElementById("api-key-input");
const modelSelect = document.getElementById("model-select");
const aiPersonaInput = document.getElementById("ai-persona-input");
const userPersonaInput = document.getElementById("user-persona-input");
const saveSettings = document.getElementById("save-settings");
const historyList = document.getElementById("history-list");
const newChatButton = document.getElementById("new-chat-button");
const typingIndicatorArea = document.getElementById("typing-indicator-area");
const viewContextButton = document.getElementById("view-context-button");
const contextModal = document.getElementById("context-modal");
const contextModalBody = document.getElementById("context-modal-body");
const modalCloseButton = document.getElementById("modal-close-button");
const chatHeaderTitle = document.getElementById("chat-header-title");


// --- Configuration & State ---
const API_URL = "https://llm.chutes.ai/v1/chat/completions";
let chutesApiKey = "";
let currentModel = "deepseek-ai/DeepSeek-V3-0324";
const DEFAULT_SYSTEM_MESSAGE_CONTENT = `Hello! I'm Velly, your helpful AI assistant. I'm here to chat and assist you with your tasks.
I have special text formatting abilities:
- *text like this* means I'm thinking or emphasizing something softly (italic).
- # TEXT LIKE THIS means I'm very enthusiastic or shouting (uppercase, bold, specific color).
- (red)text for highlighting important warnings or errors.
- (purple)text for when I'm expressing positive sentiment or creative ideas.
- (black)text for very serious or formal statements.
- (white)text is my normal way of speaking.
I'll try my best to use these to make our chats more expressive and clear! If you edit my messages, I'll adapt to the changes. Let's begin!`;
const HISTORY_HANDLING_INSTRUCTION = "\n\n**Important Note on Conversation History & Edits:** The user interface allows the user to *edit your previous responses*. The message history you are about to receive reflects the *current state* of the conversation, including any such user edits to messages that were originally yours. When you form your next response, treat the content of each message in the history (regardless of original authorship if it was an 'assistant' role that got edited) as the ground truth for continuing the dialogue. Your goal is to maintain a coherent and engaging conversation based on this *presented history*, even if an 'assistant' message in the history was modified by the user from what you might have said originally. Adapt naturally to the flow of this (potentially edited) history while staying true to your core persona described above (if one is set).";
let messages = [];
let isLoading = false;
let currentChat = { id: generateId(), title: "New Chat", messages: [] };
let chats = [];
let editingMessage = null;
let codeEditors = new Map();
let customAiPersona = "";
let currentUserPersona = "";
const icons = {
    copy: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>',
    delete: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>',
    edit: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>',
    regenerate: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></svg>',
    check: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>',
    ellipsis: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/></svg>',
    historyEdit: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>',
    historyDelete: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>'
};

function updateChatHeaderTitle(title) {
    if (chatHeaderTitle) {
        chatHeaderTitle.textContent = title || "Chat";
    }
}

function init() {
    loadSettings();
    loadChatHistory();
    if (messages.length === 0 && currentChat.messages.length === 0) {
        addWelcomeMessage();
    }
    updateChatHeaderTitle(currentChat.title);
    adjustInputHeight();
    setupEventListeners();
    require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.38.0/min/vs' }});
    require(['vs/editor/editor.main'], function() {
        console.log("Monaco Editor Core Loaded");
        renderMessages(); // Re-render if Monaco loads late
    });
}

function loadSettings() {
    try {
        const settings = localStorage.getItem("lolvableAI_settings_v3");
        if (settings) {
            const parsedSettings = JSON.parse(settings);
            currentModel = parsedSettings.model || "deepseek-ai/DeepSeek-V3-0324";
            customAiPersona = parsedSettings.aiPersona || "";
            currentUserPersona = parsedSettings.userPersona || "";
            chutesApiKey = parsedSettings.apiKey || "";

            modelSelect.value = currentModel;
            aiPersonaInput.value = customAiPersona;
            userPersonaInput.value = currentUserPersona;
            apiKeyInput.value = chutesApiKey;
        }
    } catch (error) {
        console.error("Error loading settings:", error);
    }
}

function saveSettingsToStorage() {
    try {
        localStorage.setItem("lolvableAI_settings_v3", JSON.stringify({
            model: currentModel,
            aiPersona: customAiPersona,
            userPersona: currentUserPersona,
            apiKey: chutesApiKey
        }));
    } catch (error) {
        console.error("Error saving settings:", error);
    }
}

function loadChatHistory() {
    try {
        const storedChats = localStorage.getItem("lolvableAI_chats_v2");
        if (storedChats) {
            chats = JSON.parse(storedChats);
            if (chats.length === 0) chats = [createNewChat()];
            const lastActiveChatId = localStorage.getItem("lolvableAI_lastActiveChatId_v2");
            currentChat = chats.find(chat => chat.id === lastActiveChatId) || chats[0] || createNewChat();
            if (chats.length === 0 && currentChat.id === null ) chats = [currentChat]; // ensure chats array is not empty
        } else {
            currentChat = createNewChat();
            chats = [currentChat];
        }
        messages = [...currentChat.messages];
    } catch (error) {
        console.error("Error loading chat history:", error);
        currentChat = createNewChat();
        chats = [currentChat];
        messages = [];
    }
    renderChatHistoryList();
}

function saveChatHistory() {
    try {
        currentChat.messages = [...messages];
        let chatIndex = chats.findIndex(chat => chat.id === currentChat.id);

        if (chatIndex !== -1) {
            // Auto-title new chats
            if ((chats[chatIndex].title === "New Chat" || !chats[chatIndex].title) && messages.length > 0) {
                const firstUserMessage = messages.find(m => m.role === 'user');
                if (firstUserMessage) {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = firstUserMessage.content;
                    const plainText = (tempDiv.textContent || tempDiv.innerText || "").trim();
                    const title = plainText.substring(0, 35) + (plainText.length > 35 ? "..." : "");
                    chats[chatIndex].title = title || "Chat";
                    currentChat.title = title || "Chat";
                } else if (messages.length > 0 && messages[0].role === 'assistant' && messages[0].isWelcome) {
                     chats[chatIndex].title = "Welcome Chat"; // Default for welcome message only
                     currentChat.title = "Welcome Chat";
                }
            } else if (messages.length === 0 && chats[chatIndex].title !== "New Chat") {
                 // Reset title if chat becomes empty, unless it was never named
                if (chats[chatIndex].title !== "Welcome Chat") { // Don't reset "Welcome Chat" title
                    chats[chatIndex].title = "New Chat";
                    currentChat.title = "New Chat";
                }
            } else {
                // Ensure currentChat.title is reflected if it was manually changed
                chats[chatIndex].title = currentChat.title;
            }
            chats[chatIndex] = {...currentChat}; // Update the chat in the array
        } else {
             // This case should ideally not happen if currentChat is always from `chats` or a new one added to it.
            chats.unshift({...currentChat});
            chatIndex = 0; // New chat added to the beginning
        }
        
        updateChatHeaderTitle(currentChat.title);
        localStorage.setItem("lolvableAI_chats_v2", JSON.stringify(chats));
        localStorage.setItem("lolvableAI_lastActiveChatId_v2", currentChat.id);
        renderChatHistoryList();
    } catch (error) {
        console.error("Error saving chat history:", error);
    }
}

function createNewChat() {
    return { id: generateId(), title: "New Chat", messages: [] };
}

function renderChatHistoryList() {
    if (!historyList) return;
    historyList.innerHTML = '';
    chats.forEach(chat => {
        const item = document.createElement('li');
        item.className = 'history-item';
        item.dataset.id = chat.id;
        if (chat.id === currentChat.id) {
            item.classList.add('active-chat');
        }

        const titleSpan = document.createElement('span');
        titleSpan.className = 'history-item-title';
        titleSpan.textContent = chat.title || 'Chat';
        titleSpan.title = chat.title || 'Chat';
        titleSpan.addEventListener('click', () => {
            loadChat(chat.id);
            closeSidebarAndCleanup();
        });

        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'history-item-actions';

        const renameButton = document.createElement('button');
        renameButton.className = 'history-action-btn rename-chat-btn';
        renameButton.title = 'Rename Chat';
        renameButton.innerHTML = icons.historyEdit;
        renameButton.onclick = (e) => { e.stopPropagation(); renameChatInHistory(chat.id); };
        
        const deleteButton = document.createElement('button');
        deleteButton.className = 'history-action-btn delete-chat-btn';
        deleteButton.title = 'Delete Chat';
        deleteButton.innerHTML = icons.historyDelete;
        deleteButton.onclick = (e) => { e.stopPropagation(); deleteChatFromHistory(chat.id); };

        actionsDiv.appendChild(renameButton);
        actionsDiv.appendChild(deleteButton);
        
        item.appendChild(titleSpan);
        item.appendChild(actionsDiv);
        historyList.appendChild(item);
    });
}

function renameChatInHistory(chatId) {
    const chatIndex = chats.findIndex(c => c.id === chatId);
    if (chatIndex === -1) return;

    const currentTitle = chats[chatIndex].title;
    const newTitle = prompt("Enter new chat title:", currentTitle === "New Chat" ? "" : currentTitle);

    if (newTitle !== null && newTitle.trim() !== "") {
        chats[chatIndex].title = newTitle.trim();
        if (currentChat.id === chatId) {
            currentChat.title = newTitle.trim();
            updateChatHeaderTitle(currentChat.title);
        }
        saveChatHistory(); // This will re-render the list
    }
}

function deleteChatFromHistory(chatId) {
    if (!confirm("Are you sure you want to delete this chat? This action cannot be undone.")) {
        return;
    }

    const chatIndex = chats.findIndex(c => c.id === chatId);
    if (chatIndex === -1) return;

    chats.splice(chatIndex, 1);

    if (currentChat.id === chatId) { // If deleting the active chat
        if (chats.length > 0) {
            loadChat(chats[0].id); // Load the first chat in the list
        } else {
            startNewChat(); // Or start a new one if no chats are left
        }
    } else {
        // If deleting a non-active chat, just save and re-render
        saveChatHistory();
    }
     // saveChatHistory also calls renderChatHistoryList
}


function startNewChat() {
    currentChat = createNewChat();
    chats.unshift(currentChat); // Add to the beginning of the list
    messages = [];
    addWelcomeMessage();
    saveChatHistory(); // Save and re-render list, update local storage
    renderMessages();
    updateChatHeaderTitle(currentChat.title);
    messageInput.focus();
}

function loadChat(id) {
    const chatToLoad = chats.find(chat => chat.id === id);
    if (chatToLoad) {
        currentChat = chatToLoad;
        messages = [...chatToLoad.messages];
        localStorage.setItem("lolvableAI_lastActiveChatId_v2", currentChat.id);
        renderMessages();
        renderChatHistoryList(); // To update active state
        updateChatHeaderTitle(currentChat.title);
        if (messages.length === 0) {
            addWelcomeMessage();
        }
    }
}

function addWelcomeMessage() {
     if (messages.length === 0) {
        const welcomeMsg = {
            role: "assistant",
            content: processText("Hello! (purple)I'm Velly.(white) How can I help you today?").text,
            timestamp: new Date().toISOString(),
            isWelcome: true 
        };
        messages.push(welcomeMsg);
        saveChatHistory(); 
        renderMessages();
    }
}
function generateId() { return Date.now().toString(36) + Math.random().toString(36).substring(2, 7); }
function processText(rawText) {
    let text = rawText;
    let color = null;
    if (text.startsWith("-B ")) { text = text.substring(3); color = "black"; }
    else if (text.startsWith("-P ")) { text = text.substring(3); color = "purple"; }
    else if (text.startsWith("-R ")) { text = text.substring(3); color = "red"; }

    text = text.replace(/\*(.*?)\*/g, '<em class="thinking">$1</em>');
    text = text.replace(/^#\s?(.*)/gm, '<strong class="scream">$1</strong>');
    
    text = marked.parse(text, { gfm: true, breaks: true, sanitize: false });

    text = text.replace(/\(red\)([\s\S]*?)(?=\s|$|\(|$|<)/g, '<span class="text-red">$1</span>')
               .replace(/\(purple\)([\s\S]*?)(?=\s|$|\(|$|<)/g, '<span class="text-purple">$1</span>')
               .replace(/\(black\)([\s\S]*?)(?=\s|$|\(|$|<)/g, '<span class="text-black">$1</span>')
               .replace(/\(white\)([\s\S]*?)(?=\s|$|\(|$|<)/g, '<span class="text-white">$1</span>');
    text = text.replace(/<p>\s*<\/p>/gi, ''); // Remove empty paragraphs sometimes added by marked
    return { text: text, color: color };
}

function renderMessages() {
    if (!chatBody) return;
    codeEditors.forEach(editor => editor.dispose());
    codeEditors.clear();
    chatBody.innerHTML = '';
    messages.forEach((msg, index) => {
        chatBody.appendChild(createMessageElement(msg, index));
    });
    scrollToBottom();
    if (typeof monaco !== 'undefined' && monaco.editor) {
        initCodeEditorsInChat();
    }
}

function createMessageElement(msg, index) {
    const isUser = msg.role === 'user';
    const timestamp = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${isUser ? 'user-message' : 'bot-message'}`;
    messageDiv.dataset.index = index;

    const avatarDiv = document.createElement('div');
    avatarDiv.className = `avatar ${isUser ? 'user-avatar' : 'bot-avatar'}`;
    avatarDiv.innerHTML = isUser ?
        `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>` :
        `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V4H8"/><rect width="16" height="12" x="4" y="8" rx="2"/><path d="M2 14h2"/><path d="M20 14h2"/><path d="M15 13v2"/><path d="M9 13v2"/></svg>`;
    messageDiv.appendChild(avatarDiv);

    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';

    const bubbleDiv = document.createElement('div');
    bubbleDiv.className = `message-bubble ${isUser ? 'user-bubble' : 'bot-bubble'}`;
    if (msg.color && isUser) { // Apply color class for user messages if specified
        bubbleDiv.classList.add(`text-${msg.color}`);
    }
    bubbleDiv.innerHTML = msg.content;

    const msgInfoDiv = document.createElement('div');
    msgInfoDiv.className = 'message-info';
    const timeDiv = document.createElement('div');
    timeDiv.className = 'message-time';
    timeDiv.textContent = timestamp;
    msgInfoDiv.appendChild(timeDiv);
    
    contentDiv.appendChild(bubbleDiv);
    contentDiv.appendChild(msgInfoDiv);

    // Message Actions (ellipsis button and menu)
    const actionsTrigger = document.createElement('button');
    actionsTrigger.className = 'message-actions-trigger';
    actionsTrigger.innerHTML = icons.ellipsis;
    actionsTrigger.setAttribute('aria-label', 'Message actions');
    actionsTrigger.onclick = (e) => { e.stopPropagation(); toggleActionsMenu(index); };

    const actionsMenu = document.createElement('div');
    actionsMenu.className = 'message-actions-menu';
    actionsMenu.id = `actions-menu-${index}`;
    
    actionsMenu.appendChild(createActionButton(icons.edit + ' Edit', () => editMessage(index)));
    actionsMenu.appendChild(createActionButton(icons.copy + ' Copy Text', () => {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = msg.content;
        let textToCopy = (tempDiv.textContent || tempDiv.innerText || "")
            .replace(/\*(.*?)\*/g, '$1') // Remove emphasis markers for copy
            .replace(/^#\s?(.*)/gm, '$1'); // Remove scream markers for copy
        copyToClipboard(textToCopy, actionsMenu.querySelector('.action-button:nth-child(2)')); // Pass the button element itself
    }));
    if (!isUser) {
        actionsMenu.appendChild(createActionButton(icons.regenerate + ' Regenerate', () => regenerateResponse(index)));
    }
    actionsMenu.appendChild(createActionButton(icons.delete + ' Delete', () => deleteMessage(index), 'delete'));

    contentDiv.appendChild(actionsTrigger);
    contentDiv.appendChild(actionsMenu);
    messageDiv.appendChild(contentDiv);
    return messageDiv;
}

function createActionButton(innerHTML, onClick, additionalClass = '') {
    const button = document.createElement('button');
    button.className = 'action-button';
    if (additionalClass) button.classList.add(additionalClass);
    button.innerHTML = innerHTML;
    button.addEventListener('click', (e) => {
        e.stopPropagation();
        onClick();
        closeAllActionMenus();
    });
    return button;
}

function toggleActionsMenu(index) {
    const menu = document.getElementById(`actions-menu-${index}`);
    const isActive = menu.classList.contains('active');
    closeAllActionMenus(); // Close any other open menus
    if (!isActive) {
        menu.classList.add('active');
    }
}

function closeAllActionMenus() {
    document.querySelectorAll('.message-actions-menu.active').forEach(m => m.classList.remove('active'));
}
// Global click listener to close action menus
document.addEventListener('click', (e) => {
    if (!e.target.closest('.message-actions-trigger') && !e.target.closest('.message-actions-menu')) {
        closeAllActionMenus();
    }
});


function getRawTextFromHtml(htmlContent) {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlContent;

    // Convert specific formatting back to raw text markers
    tempDiv.querySelectorAll('em.thinking').forEach(el => el.replaceWith(`*${el.textContent}*`));
    tempDiv.querySelectorAll('strong.scream').forEach(el => el.replaceWith(`# ${el.textContent}`));
    tempDiv.querySelectorAll('span.text-red').forEach(el => el.replaceWith(`(red)${el.innerHTML}`)); // Keep inner HTML for nested
    tempDiv.querySelectorAll('span.text-purple').forEach(el => el.replaceWith(`(purple)${el.innerHTML}`));
    tempDiv.querySelectorAll('span.text-black').forEach(el => el.replaceWith(`(black)${el.innerHTML}`));
    tempDiv.querySelectorAll('span.text-white').forEach(el => el.replaceWith(`(white)${el.innerHTML}`));

    // Handle code blocks
    tempDiv.querySelectorAll('pre code').forEach(codeElement => {
        const lang = codeElement.className.match(/language-(\w+)/)?.[1] || '';
        codeElement.parentElement.replaceWith("```" + lang + "\n" + codeElement.textContent + "\n```");
    });
    
    // For other HTML, try to get textContent; this might need refinement for complex HTML
    return (tempDiv.textContent || tempDiv.innerText || "").trim();
}

function editMessage(index) {
    if (editingMessage && editingMessage.index === index) return; // Already editing this one
    if (editingMessage) cancelEdit(); // Cancel any other ongoing edit

    const messageData = messages[index];
    const messageElement = document.querySelector(`.message[data-index="${index}"]`);
    if (!messageData || !messageElement) return;

    const bubbleElement = messageElement.querySelector('.message-bubble');
    const rawContentForEditing = getRawTextFromHtml(messageData.content);

    editingMessage = { index, originalBubbleHTML: bubbleElement.innerHTML };
    
    bubbleElement.style.display = 'none'; // Hide original bubble

    const editTextArea = document.createElement('textarea');
    editTextArea.className = 'edit-area';
    editTextArea.value = rawContentForEditing;

    const editControls = document.createElement('div');
    editControls.className = 'edit-controls';

    const saveButton = document.createElement('button');
    saveButton.className = 'edit-button';
    saveButton.textContent = 'Save';
    saveButton.onclick = () => saveEditedMessage(index, editTextArea.value);

    const cancelButton = document.createElement('button');
    cancelButton.className = 'cancel-button';
    cancelButton.textContent = 'Cancel';
    cancelButton.onclick = () => cancelEdit();

    editControls.appendChild(cancelButton);
    editControls.appendChild(saveButton);

    // Insert edit area and controls after the (now hidden) bubble
    bubbleElement.insertAdjacentElement('afterend', editControls);
    bubbleElement.insertAdjacentElement('afterend', editTextArea);
    
    editTextArea.focus();
    // Auto-adjust height
    editTextArea.style.height = 'auto';
    editTextArea.style.height = (editTextArea.scrollHeight) + 'px';
    editTextArea.addEventListener('input', () => {
        editTextArea.style.height = 'auto';
        editTextArea.style.height = (editTextArea.scrollHeight) + 'px';
    });
}

function saveEditedMessage(index, newRawContent) {
    if (index < 0 || index >= messages.length) return;
    const originalMessage = messages[index];
    const { text: processedContent, color: detectedColor } = processText(newRawContent);

    messages[index] = {
        ...originalMessage,
        content: processedContent,
        raw: newRawContent, // Store the new raw content
        color: detectedColor || originalMessage.color, // Retain original color if new one not detected, or use new
        timestamp: new Date().toISOString(),
        edited: true
    };
    
    cancelEditCleanup(); // Remove edit UI elements
    editingMessage = null;
    saveChatHistory();
    renderMessages();
}

function cancelEdit() {
    if (!editingMessage) return;
    const messageElement = document.querySelector(`.message[data-index="${editingMessage.index}"]`);
    if (messageElement) {
        const bubbleElement = messageElement.querySelector('.message-bubble');
        if (bubbleElement) {
            bubbleElement.innerHTML = editingMessage.originalBubbleHTML; // Restore original content
            bubbleElement.style.display = ''; // Make it visible again
        }
        // Remove edit UI elements
        const editArea = messageElement.querySelector('.edit-area');
        if (editArea) editArea.remove();
        const editControls = messageElement.querySelector('.edit-controls');
        if (editControls) editControls.remove();
    }
    editingMessage = null;
}
function cancelEditCleanup() { // Separate cleanup for use by save as well
    if (!editingMessage) return;
    const messageElement = document.querySelector(`.message[data-index="${editingMessage.index}"]`);
    if (messageElement) {
        const editArea = messageElement.querySelector('.edit-area');
        if (editArea) editArea.remove();
        const editControls = messageElement.querySelector('.edit-controls');
        if (editControls) editControls.remove();
        const bubbleElement = messageElement.querySelector('.message-bubble');
        if(bubbleElement) bubbleElement.style.display = ''; // Ensure bubble is visible
    }
}


function deleteMessage(index) {
    if (index < 0 || index >= messages.length) return;
    const messageElement = document.querySelector(`.message[data-index="${index}"]`);
    if (messageElement) {
        messageElement.classList.add('delete-animation');
        setTimeout(() => {
            messages.splice(index, 1);
            saveChatHistory();
            renderMessages(); // Re-render to update indices and UI
        }, 300); // Match animation duration
    } else {
        // Fallback if element not found (should not happen)
        messages.splice(index, 1);
        saveChatHistory();
        renderMessages();
    }
}

function regenerateResponse(botMessageIndex) {
    if (isLoading || botMessageIndex <= 0 || botMessageIndex >= messages.length || messages[botMessageIndex].role !== 'assistant') {
        return;
    }
    // The message *before* the bot's message should be the user's prompt
    const userMessageIndex = botMessageIndex - 1;
    if (userMessageIndex < 0 || messages[userMessageIndex].role !== 'user') {
        // This could happen if the first message is a bot message (e.g. welcome) or structure is unexpected
        console.warn("Cannot regenerate: No preceding user message found for bot message at index", botMessageIndex);
        return;
    }

    // Remove the bot message we want to regenerate
    messages.splice(botMessageIndex, 1);
    saveChatHistory(); // Save this removal
    renderMessages(); // Update UI to show removal

    // Get the raw content of the user's prompt that led to the original bot response
    const userMessageForApi = messages[userMessageIndex];
    const rawUserContent = userMessageForApi.raw || getRawTextFromHtml(userMessageForApi.content);

    // Send this raw content again, but don't add it as a *new* user message to the list
    sendMessage(rawUserContent, userMessageForApi.color, false);
}

function initCodeEditorsInChat() {
    if (typeof monaco === 'undefined' || !monaco.editor) {
        console.warn("Monaco is not available. Code blocks will be plain text.");
        return;
    }
    // Dispose old editors before creating new ones
    codeEditors.forEach(editor => editor.dispose());
    codeEditors.clear();

    document.querySelectorAll('.chat-body pre > code').forEach((codeElement) => {
        const preElement = codeElement.parentElement;
        if (!preElement || preElement.tagName !== 'PRE' || preElement.dataset.editorInitialized === 'true') {
            return; // Already initialized or not a direct child of PRE
        }
        preElement.dataset.editorInitialized = 'true'; // Mark as initialized

        const languageMatch = codeElement.className.match(/language-(\w+)/);
        const language = languageMatch ? languageMatch[1] : 'plaintext';
        const code = codeElement.textContent || '';
        const editorId = `editor-${generateId()}`;

        const editorContainer = document.createElement('div');
        editorContainer.id = editorId;
        editorContainer.className = 'code-editor'; // For styling editor height etc.
        
        // Create header for language and copy button
        const codeHeader = document.createElement('div');
        codeHeader.className = 'code-header';
        const langSpan = document.createElement('span');
        langSpan.className = 'code-language';
        langSpan.textContent = language;
        const copyButton = document.createElement('button');
        copyButton.className = 'code-copy';
        copyButton.innerHTML = icons.copy + ' Copy';
        copyButton.onclick = () => copyCode(code, copyButton);
        
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'code-actions';
        actionsDiv.appendChild(copyButton);

        codeHeader.appendChild(langSpan);
        codeHeader.appendChild(actionsDiv);

        const codeBlockDiv = document.createElement('div');
        codeBlockDiv.className = 'code-block'; // Wraps header and editor

        // Replace <pre> with our structure
        preElement.parentNode.replaceChild(codeBlockDiv, preElement);
        codeBlockDiv.appendChild(codeHeader);
        codeBlockDiv.appendChild(editorContainer);
        
        try {
            const editor = monaco.editor.create(editorContainer, {
                value: code,
                language: language,
                theme: 'vs-dark',
                readOnly: true,
                minimap: { enabled: false },
                scrollBeyondLastLine: false,
                automaticLayout: true, // Important for responsive resizing
                wordWrap: 'on',
                renderWhitespace: "boundary",
                scrollbar: { verticalScrollbarSize: 8, horizontalScrollbarSize: 8 }
            });
            codeEditors.set(editorId, editor);
        } catch(error) {
            console.error("Monaco Editor creation failed:", error);
            // Fallback to show plain code if Monaco fails
            editorContainer.textContent = `Error loading code: ${error.message}\n\n${code}`;
            editorContainer.style.cssText = 'white-space: pre-wrap; font-family: monospace; background-color: #1e293b; padding: 1rem; color: #fff;';
        }
    });
}

function copyCode(code, buttonElement) {
    navigator.clipboard.writeText(code).then(() => {
        const originalHtml = buttonElement.innerHTML;
        buttonElement.innerHTML = icons.check + ' Copied!';
        buttonElement.classList.add('code-copy-success');
        setTimeout(() => {
            buttonElement.innerHTML = originalHtml;
            buttonElement.classList.remove('code-copy-success');
        }, 1500);
    }).catch(err => {
        console.error('Failed to copy code: ', err);
        buttonElement.textContent = 'Error';
        setTimeout(() => { buttonElement.innerHTML = icons.copy + ' Copy'; }, 1500);
    });
}

function adjustInputHeight() {
    messageInput.style.height = 'auto'; // Reset height
    let scrollHeight = messageInput.scrollHeight;
    const maxHeight = parseInt(window.getComputedStyle(messageInput).maxHeight, 10) || 200;

    if (scrollHeight > maxHeight) {
        messageInput.style.height = maxHeight + 'px';
        messageInput.style.overflowY = 'auto';
    } else {
        messageInput.style.height = scrollHeight + 'px';
        messageInput.style.overflowY = 'hidden';
    }
    sendButton.disabled = messageInput.value.trim() === '' || isLoading;
}

function showTypingIndicator() {
    hideTypingIndicator(); // Ensure only one indicator
    const indicatorHtml = `
        <div class="message bot-message typing-indicator" id="bot-typing-indicator">
            <div class="avatar bot-avatar">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V4H8"/><rect width="16" height="12" x="4" y="8" rx="2"/><path d="M2 14h2"/><path d="M20 14h2"/><path d="M15 13v2"/><path d="M9 13v2"/></svg>
            </div>
            <div class="message-content">
                <div class="message-bubble bot-bubble typing-text">
                    Velly is typing<span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>
                </div>
            </div>
        </div>`;
    typingIndicatorArea.innerHTML = indicatorHtml;
    scrollToBottom();
}
function hideTypingIndicator() {
    typingIndicatorArea.innerHTML = '';
}

function scrollToBottom() {
    setTimeout(() => { // Timeout to allow DOM to update
        chatBody.scrollTop = chatBody.scrollHeight;
    }, 50);
}

function copyToClipboard(text, buttonElement) {
    navigator.clipboard.writeText(text).then(() => {
        if (buttonElement) {
            const originalHtml = buttonElement.innerHTML;
            // Assuming the icon is the first child of the button, or part of innerHTML
            const buttonText = buttonElement.textContent.replace(/Edit|Copy Text|Regenerate|Delete/i, '').trim();
            buttonElement.innerHTML = icons.check + ' Copied!';
            setTimeout(() => {
                buttonElement.innerHTML = originalHtml; // Restore original content
            }, 1500);
        }
    }).catch(err => {
        console.error('Failed to copy text: ', err);
        if (buttonElement) {
             const originalHtml = buttonElement.innerHTML;
             buttonElement.innerHTML = 'Error'; // Or icons.error + ' Error'
             setTimeout(() => { buttonElement.innerHTML = originalHtml; }, 1500);
        }
    });
}

function showContextModal() {
    let systemMessageForDisplay;
    if (customAiPersona && customAiPersona.trim() !== "") {
        systemMessageForDisplay = customAiPersona;
    } else {
        systemMessageForDisplay = DEFAULT_SYSTEM_MESSAGE_CONTENT + HISTORY_HANDLING_INSTRUCTION;
    }

    let apiMessagesForDisplay = [{ role: "system", content: systemMessageForDisplay }];

    const contextWindow = messages.slice(-15); // Consider last 15 messages for context display
    contextWindow.forEach(msg => {
        let displayContent = msg.raw || getRawTextFromHtml(msg.content); // Use raw if available
        if (msg.role === 'user' && currentUserPersona && msg.raw) { // If it's a user message with persona, show how it's prefixed
             displayContent = `[User Persona: ${currentUserPersona}]\n\n${msg.raw}`;
        }
        apiMessagesForDisplay.push({ role: msg.role, content: displayContent.trim() });
    });

    contextModalBody.innerHTML = '';
    apiMessagesForDisplay.forEach(msg => {
        const entryDiv = document.createElement('div');
        entryDiv.className = 'context-entry';
        const roleDiv = document.createElement('div');
        roleDiv.className = 'context-role';
        roleDiv.textContent = msg.role;
        const textDiv = document.createElement('div');
        textDiv.className = 'context-text';
        textDiv.textContent = msg.content; // Display the content that would be sent
        entryDiv.appendChild(roleDiv);
        entryDiv.appendChild(textDiv);
        contextModalBody.appendChild(entryDiv);
    });
    contextModal.classList.add('active');
}


// --- Sidebar Open/Close Helper ---
function openSidebar() {
    if (sidebar && !sidebar.classList.contains('open')) {
        sidebar.classList.add('open');
        // Optional: Prevent body scroll when sidebar is open on mobile
        if (window.innerWidth <= 768) {
            document.body.style.overflow = 'hidden';
        }
        // Add listener to close on outside click
        setTimeout(() => { document.addEventListener('click', handleClickOutsideSidebar, true); }, 0);
    }
}
function closeSidebarAndCleanup() {
    if (sidebar && sidebar.classList.contains('open')) {
        sidebar.classList.remove('open');
        if (window.innerWidth <= 768) {
            document.body.style.overflow = '';
        }
        document.removeEventListener('click', handleClickOutsideSidebar, true);
    }
}
function handleClickOutsideSidebar(event) {
    // Check if the sidebar is open and the click is outside the sidebar and not on the menu button
    if (sidebar.classList.contains('open') &&
        !sidebar.contains(event.target) &&
        event.target !== menuButton && !menuButton.contains(event.target) // Ensure menu button itself doesn't close
        ) {
        closeSidebarAndCleanup();
    }
}

async function sendMessage(userRawInput, userBubbleColor, addUserMessageToList = true) {
    const trimmedInput = userRawInput.trim();
    if (!trimmedInput && addUserMessageToList) return; // Don't send empty messages if it's a new user input
    if (isLoading) return;

    if (!chutesApiKey || chutesApiKey.trim() === '') {
        alert("Please enter your Chutes.AI API Key in Settings.");
        openSidebar();
        // Switch to settings tab
        sidebarTabs.forEach(t => t.classList.remove('active'));
        document.querySelector('.sidebar-tab[data-tab="settings"]').classList.add('active');
        historyTab.style.display = 'none';
        settingsTab.style.display = 'block';
        apiKeyInput.focus();
        return;
    }

    isLoading = true;
    sendButton.disabled = true;
    messageInput.disabled = true;

    let currentUserTurnContentForApi = trimmedInput;
    if (currentUserPersona && trimmedInput) { // Apply persona only if there's actual input
        currentUserTurnContentForApi = `[User Persona: ${currentUserPersona}]\n\n${trimmedInput}`;
    }

    if (addUserMessageToList) {
        const { text: processedInputHtml, color: detectedUserMsgColor } = processText(trimmedInput);
        const userMessage = {
            role: "user",
            content: processedInputHtml,
            raw: trimmedInput, // Store the original raw input
            timestamp: new Date().toISOString(),
            color: userBubbleColor || detectedUserMsgColor // Use passed color or detected one
        };
        messages.push(userMessage);
        renderMessages(); // Display user message immediately
    }
    
    showTypingIndicator();
    saveChatHistory(); // Save user message and potential title update

    let systemMessageForApi;
    if (customAiPersona && customAiPersona.trim() !== "") {
        systemMessageForApi = customAiPersona;
    } else {
        systemMessageForApi = DEFAULT_SYSTEM_MESSAGE_CONTENT + HISTORY_HANDLING_INSTRUCTION;
    }
    
    const apiMessagePayload = [{ role: "system", content: systemMessageForApi }];

    // Build history for API: use `raw` for user messages and AI's raw response if available, else process HTML back.
    // Take a slice of `messages` for context window.
    // Exclude the very last message if `addUserMessageToList` is true, because its API version (`currentUserTurnContentForApi`) will be added after the loop.
    let historyForApi = messages.slice(-105); // Max 105 messages in context, adjust as needed.
    if (addUserMessageToList && historyForApi.length > 0) {
        historyForApi = historyForApi.slice(0, -1); // Remove the message just added for display.
    }
    
    historyForApi.forEach(msg => {
        if (msg.role === "user") {
            // For past user messages, if persona was used, it would be in msg.raw already
            // However, the current design applies persona only to the *current* turn.
            // So, for history, just send msg.raw or processed content.
            // For simplicity & consistency with how `currentUserTurnContentForApi` is built,
            // let's assume past user messages in `messages` store their "final" form for the API.
            // If `msg.raw` includes persona, it's fine. If not, it's also fine.
            // The most important is that `currentUserTurnContentForApi` is correct for the *current* turn.
             apiMessagePayload.push({ role: "user", content: (currentUserPersona && (msg.raw || getRawTextFromHtml(msg.content))) ? `[User Persona: ${currentUserPersona}]\n\n${msg.raw || getRawTextFromHtml(msg.content)}` : (msg.raw || getRawTextFromHtml(msg.content)).trim() });

        } else if (msg.role === "assistant") {
            apiMessagePayload.push({ role: "assistant", content: (msg.raw || getRawTextFromHtml(msg.content)).trim() });
        }
    });

    // Add the current user's turn content (which has persona prepended if applicable)
    // This ensures that if `addUserMessageToList` was false (e.g., for regeneration),
    // `trimmedInput` (which is `userRawInput`) is still added here.
    if (trimmedInput) { // Only add if there was actual input
        apiMessagePayload.push({ role: "user", content: currentUserTurnContentForApi.trim() });
    }

    console.log("API Key:", chutesApiKey ? "Exists" : "MISSING!");
    console.log("Final API Messages to be sent:", JSON.parse(JSON.stringify(apiMessagePayload)));

    try {
        const response = await fetch(API_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json", "Authorization": `Bearer ${chutesApiKey}` },
            body: JSON.stringify({
                model: currentModel,
                messages: apiMessagePayload,
                stream: false, // Set to true for streaming if API supports and you implement handling
                max_tokens: 1500, // Adjust as needed
                temperature: 0.75 // Adjust for creativity vs. determinism
            })
        });
        hideTypingIndicator();
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ detail: `HTTP error! status: ${response.status}` }));
            throw new Error(errorData.detail || errorData.error?.message || `API Error (${response.status})`);
        }
        const data = await response.json();
        if (!data.choices || !data.choices[0] || !data.choices[0].message) {
            throw new Error("Invalid API response structure.");
        }
        const botRawResponse = data.choices[0].message.content;
        const { text: processedBotResponseHtml } = processText(botRawResponse);
        const botMessage = {
            role: "assistant",
            content: processedBotResponseHtml,
            raw: botRawResponse, // Store AI's raw response for potential future use (e.g. if it edits its own messages)
            timestamp: new Date().toISOString()
        };
        messages.push(botMessage);
        saveChatHistory(); // Save AI response and potential title update

    } catch (error) {
        console.error("Error fetching/processing API response:", error);
        hideTypingIndicator();
        const { text: processedError } = processText(`(red)Oh noes! Something went wrong: ${error.message}`);
        const errorMessage = { role: "assistant", content: processedError, timestamp: new Date().toISOString(), color: "red" };
        messages.push(errorMessage);
        saveChatHistory(); // Save error message
    } finally {
        isLoading = false;
        renderMessages(); // Render final state including AI response or error
        if (addUserMessageToList) { // Clear input only if it was a new user message submission
            messageInput.value = '';
        }
        adjustInputHeight();
        messageInput.disabled = false;
        sendButton.disabled = messageInput.value.trim() === '';
        messageInput.focus();
    }
}


function setupEventListeners() {
    messageInput.addEventListener('input', adjustInputHeight);
    sendButton.addEventListener('click', () => {
        if (!sendButton.disabled) {
            const { color: detectedColor } = processText(messageInput.value); // Detect color intent
            sendMessage(messageInput.value, detectedColor);
        }
    });
    messageInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey && !sendButton.disabled) {
            event.preventDefault();
            const { color: detectedColor } = processText(messageInput.value);
            sendMessage(messageInput.value, detectedColor);
        }
    });

    if (menuButton) {
        menuButton.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent click from immediately closing via handleClickOutsideSidebar
            if (sidebar.classList.contains('open')) {
                closeSidebarAndCleanup();
            } else {
                openSidebar();
            }
        });
    }
    if (sidebarClose) { sidebarClose.addEventListener('click', () => { closeSidebarAndCleanup(); }); }
    if (newChatButton) {
        newChatButton.addEventListener('click', () => {
            startNewChat();
            closeSidebarAndCleanup();
        });
    }

    sidebarTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            sidebarTabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            historyTab.style.display = tab.dataset.tab === 'history' ? 'block' : 'none';
            settingsTab.style.display = tab.dataset.tab === 'settings' ? 'block' : 'none';
        });
    });

    if (saveSettings) {
        saveSettings.addEventListener('click', () => {
            currentModel = modelSelect.value;
            customAiPersona = aiPersonaInput.value.trim();
            currentUserPersona = userPersonaInput.value.trim();
            chutesApiKey = apiKeyInput.value.trim();
            saveSettingsToStorage();
            alert('Settings saved!');
            closeSidebarAndCleanup();
            // Optional: If persona changes, you might want to offer to start a new chat or indicate the change.
        });
    }
    if (viewContextButton) viewContextButton.addEventListener('click', showContextModal);
    if (modalCloseButton) modalCloseButton.addEventListener('click', () => contextModal.classList.remove('active'));
    if (contextModal) contextModal.addEventListener('click', (event) => {
        if (event.target === contextModal) { // Click on modal backdrop
            contextModal.classList.remove('active');
        }
    });
}

// --- Run Initialization ---
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
